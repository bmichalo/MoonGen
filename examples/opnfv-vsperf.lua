-- vim:ts=4:sw=4:noexpandtab
--- This script can be used to determine if a device is affected by the corrupted packets
--  that are generated by the software rate control method.
--  It generates CBR traffic via both methods and compares the resulting latency distributions.
--  TODO: this module should also test L3 traffic (but not just L3 due to size constraints (timestamping limitations))
local dpdk      = require "dpdk"
local memory    = require "memory"
local ts        = require "timestamping"
local device    = require "device"
local filter    = require "filter"
local timer     = require "timer"
local stats     = require "stats"
local hist      = require "histogram"
-- required here because this script creates *a lot* of mempools
-- memory.enableCache()

-------------------------------------------------------------------------------
-- "Constants"
-------------------------------------------------------------------------------
local REPS = 1
local run_time = 15
local LATENCY_TRIM = 3000 -- time in ms to delayied start and early end to latency mseasurement, so we are certain main packet load is present
local FRAME_SIZE = 64
local BIDIREC = 0 --do not do bidirectional test
local LATENCY = 0 --do not get letency measurements
local MAX_FRAME_LOSS_PCT = 0
local LINE_RATE = 10000000000 -- 10Gbps
local RATE_GRANULARITY = 0.1
local TX_HW_RATE_TOLERANCE_MPPS = 0.250  -- The acceptable difference between actual and measured TX rates (in Mpps)
local TX_SW_RATE_TOLERANCE_MPPS = 0.250  -- The acceptable difference between actual and measured TX rates (in Mpps)
local ETH_DST   = "10:11:12:13:14:15" -- src mac is taken from the NIC
local IP_SRC    = "192.168.0.10"
local IP_DST    = "10.0.0.1"
local PORT_SRC  = 1234
local PORT_DST  = 1234
local NUM_FLOWS = 256 -- src ip will be IP_SRC + (0..NUM_FLOWS-1)


function master(...)
	local port1, port2, frame_size, bidirec, max_acceptable_frame_loss_pct, num_flows, max_line_rate_Mfps = tonumberall(...)

        if not port1 or not port2 then
            printf("\n\n");
	    printf("Usage: \n");
	    printf("         opnfv-vsperf.lua Port1 Port2 [Frame Size] [Traffic Direction] [Maximum Acceptable Frame Loss] [Number of Flows] [Maximum Frames Per Second]\n\n");
            printf("             where:\n");
            printf("                Port1 ............................ The first DPDK enabled port of interest, e.g. 0\n");
            printf("                Port2 ............................ The second DPDK enabled port of interest, e.g. 1\n");
            printf("                Frame Size ....................... Frame size in bytes.  This is the 'goodput' payload size in bytes.  It does not include");
            printf("                                                   the preamble (7 octets), start of frame delimited (1 octet), and interframe gap (12 octets). ");
            printf("                                                   The default size is 64. \n");
            printf("                Traffic Direction ................ Unidirectional (0) or bidirectional (1) traffic flow between Port1 and Port2.  Default is unidirectional\n");
            printf("                Maximum Acceptable Frame Loss .... Percentage of acceptable packet loss.  Default is 0\n");
            printf("                Number of Flows .................. Number of packet flows.  Default is 256\n");
            printf("                Maximum Frames Per Second ........ The maximum number of frames per second (in Mfps).  For a 10 Gbps connection, this would be 14.88 (also the default)");
            printf("\n\n");
            return
	end

	frame_size = frame_size or FRAME_SIZE
	bidirec = bidirec or BIDIREC
	max_acceptable_frame_loss_pct = max_acceptable_frame_loss_pct or MAX_FRAME_LOSS_PCT
	max_line_rate_Mfps = max_line_rate_Mfps or (LINE_RATE /(frame_size*8 +64 +96) /1000000) --max_line_rate_Mfps is in millions per second
	num_flows = num_flows or NUM_FLOWS
	rate_granularity = RATE_GRANULARITY
	latency = LATENCY

	-- assumes port1 and port2 are not the same
	local numQueues = 1 
	if (latency == 1) then
		numQueues = numQueues + 1 
	end
	local prevRate = 0
	local prevPassRate = 0
	local frame_loss = 0
	local prevFailRate = max_line_rate_Mfps
	local rate = max_line_rate_Mfps
        local method = "hardware"
        local final_validation_ctr = 0
	local rateToleranceRetry = 0
	if ( method == "hardware" ) then
		tx_rate_tolerance = TX_HW_RATE_TOLERANCE_MPPS
	else
		tx_rate_tolerance = TX_SW_RATE_TOLERANCE_MPPS
	end

	printf("Starting binary search for maximum throughput with no more than %.8f%% packet loss", max_acceptable_frame_loss_pct);
	while ( math.abs(rate - prevRate) > rate_granularity or finalValidation == true ) do
                local devs = {}
		devs[1] = device.config{ port = port1, rxQueues = numQueues, txQueues = numQueues}
		devs[2] = device.config{ port = port2, rxQueues = numQueues, txQueues = numQueues}
                device.waitForLinks()

                printf("TOP OF WHILE LOOP:  Testing with prevPassRate = %.2f, prevFailRate = %.2f, prevRate = %.2f, rate = %.2f", prevPassRate, prevFailRate, prevRate, rate); 
	        if finalValidation == true then
	            printf("Starting final validation");
		end
	        local r = {}
		launchTest(devs[1], devs[2], rate, bidirec, 0, frame_size, run_time, num_flows, method, r)
                local dev1_total_tx_frames = r[1]
                local dev2_total_tx_frames = r[2]
                local dev1_total_rx_frames = r[3]
                local dev2_total_rx_frames = r[4]
		local dev1_avg_txMpps = r[5]
		local dev2_avg_rxMpps = r[6]
	        if finalValidation == true then
	            printf("Stopping final validation");
		end

		local rateDiff = math.abs(rate - dev1_avg_txMpps)
                if (rateDiff > tx_rate_tolerance) then
		    if rateToleranceRetry > 1 then
                    	printf("ABORT TEST:  the difference between actual and requested Tx rate (%.2f) is greater than allowed (%.2f)", rateDiff, tx_rate_tolerance)
                        return
		    else
                    	printf("RETRY TEST: the difference between actual and requested Tx rate (%.2f) is greater than allowed (%.2f)", rateDiff, tx_rate_tolerance)
			rateToleranceRetry = rateToleranceRetry + 1
		    end
		else
		    	rateToleranceRetry = 0
			rate = dev1_avg_txMpps -- the actual rate may be lower, so correct "rate"
			prevRate = rate
			local dev1_lost_frames = dev1_total_tx_frames - dev2_total_rx_frames
			local dev2_lost_frames = dev2_total_tx_frames - dev1_total_rx_frames
			local frame_loss_pct = 100 * (dev1_lost_frames + dev2_lost_frames) / (dev1_total_tx_frames + dev2_total_tx_frames)
	        	if frame_loss_pct > max_acceptable_frame_loss_pct then --failed to have <= max_acceptable_frame_loss_pct, lower rate
				if finalValidation == true then
					finalValidation = false
				end
				printf("Test Result:  FAILED - frame loss (%d, %.8f%%), which is greater than the maximum allowed (%.8f%%)", dev1_lost_frames + dev2_lost_frames, frame_loss_pct, max_acceptable_frame_loss_pct);
				nextRate = (prevPassRate + rate ) / 2
				if math.abs(nextRate - rate) <= rate_granularity then
			    		finalValidation = true
				end
				prevFailRate = rate
			    	rate = nextRate
			else --acceptable packet loss, increase rate
				printf("Test Result:  PASSED - frame loss (%d, %.8f%%), which is not greater than the maximum allowed (%.8f%%)", dev1_lost_frames + dev2_lost_frames, frame_loss_pct, max_acceptable_frame_loss_pct);
				if finalValidation == true then
					printf("Test is complete")
					return
				else
			    	nextRate = (prevFailRate + rate ) / 2
			    	if math.abs(nextRate - rate) <= rate_granularity then
					finalValidation = true
			    	else
					prevPassRate = rate
					rate = nextRate
			    	end
				end
			end
			if not dpdk.running() then
				break
			end
		end
                printf("BOTTOM OF WHILE LOOP:  Testing with prevPassRate = %.2f, prevFailRate = %.2f, prevRate = %.2f, rate = %.2f", prevPassRate, prevFailRate, prevRate, rate); 
	end
end

function launchTest(dev1, dev2, rate, bidirec, latency, frame_size, run_time, num_flows, method, t)
		local total_rate = rate
		local qid = 0
		if (bidirec == 1) then
			total_rate = rate * 2
		end

		calibrateTask1a = dpdk.launchLua("calibrateSlave", dev1:getTxQueue(qid), rate, frame_size, num_flows, method)
		local c1 = {}
		c1 = calibrateTask1a:wait()
		dev1CalibratedRate = c1[1]
		if (bidirec == 1) then
			calibrateTask2a = dpdk.launchLua("calibrateSlave", dev2:getTxQueue(qid), rate, frame_size, num_flows, method)
			c1 = calibrateTask2a:wait()
			dev2CalibratedRate = c1[1]
		end

		-- first start the tasks that count reveiced packets
		rxTask1a = dpdk.launchLua("counterSlave", dev2:getRxQueue(qid), run_time + 6)
		if (bidirec == 1) then
			rxTask2a = dpdk.launchLua("counterSlave", dev1:getRxQueue(qid), run_time + 6)
		end
		dpdk.sleepMillis(3000)

		-- now start the tasks that generate the load
		loadTask1a = dpdk.launchLua("loadSlave", dev1:getTxQueue(qid), rate, dev1CalibratedRate, frame_size, run_time, num_flows, method)
		if (bidirec == 1) then
			loadTask1b = dpdk.launchLua("loadSlave", dev2:getTxQueue(qid), rate, dev2CalibratedRate, frame_size, run_time, num_flows, method)
		end

		-- and optinally take latency measurements
		if (latency == 1) then
			qid = qid + 1
			loadTask2a = dpdk.launchLua("timerSlave", dev1:getTxQueue(qid), dev2:getRxQueue(qid), frame_size, run_time, num_flows)
		end

               	local dev1_total_tx_frames = 0
               	local dev2_total_tx_frames = 0
               	local dev1_total_rx_frames = 0
               	local dev2_total_rx_frames = 0
		local dev1_avg_txMpps = 0
		local dev2_avg_rxMpps = 0
                
		-- wait for the tasks that generate load to finish
		local r1 = {}
		r1 = loadTask1a:wait()
                dev1_total_tx_frames = r1[1]
		dev1_avg_txMpps = r1[2]
		if (bidirec == 1) then
		    local r2 = {}
		    r2 = loadTask1b:wait()
                    dev2_total_tx_frames = r2[1];
		    dev2_avg_txMpps = r2[2]
		end

		-- wait for the tasks that count received packets to finish
		rx1 = rxTask1a:wait()
                dev2_total_rx_frames = rx1[1]
		if (bidirec == 1) then
			rx2 = rxTask2a:wait()
                	dev1_total_rx_frames = rx2[1]
                end
                
		-- finally, wait for latency task if one was used
		if (latency == 1) then
			loadTask2a:wait()
		end

                t[1] = dev1_total_tx_frames
                t[2] = dev2_total_tx_frames
                t[3] = dev1_total_rx_frames
                t[4] = dev2_total_rx_frames
		t[5] = dev1_avg_txMpps
		t[6] = dev2_avg_txMpps
end

function calibrateSlave(txQueue, desiredRate, frame_size, num_flows, method)
	printf("Calibrating %s tx rate for %.2f Mfs",  method , desiredRate)
	local frame_size_without_crc = frame_size - 4
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	local mem = memory.createMemPool(function(buf)
		buf:getUdpPacket():fill{
			pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
			ethSrc = txQueue, -- get the src mac from the device
			ethDst = ETH_DST,
			ip4Dst = IP_DST,
			udpSrc = PORT_SRC,
			udpDst = PORT_DST,
		}
	end)
	local bufs = mem:bufArray()
	local baseIP = parseIPAddress(IP_SRC)
	local measuredRate = 0
	local prevMeasuredRate = 0
	local calibratedRate = desiredRate
	local isCalibrated = false
	local calibrationCount = 0
	local overcorrection = 1
	repeat
		local count = 0
		local txStats = stats:newDevTxCounter(txQueue, "plain")
		if ( method == "hardware" ) then
			txQueue:setRateMpps(calibratedRate)
			rate_accuracy = TX_HW_RATE_TOLERANCE_MPPS / 2
			runtime = timer:new(5)
		else
			rate_accuracy = TX_SW_RATE_TOLERANCE_MPPS / 2
			-- s/w rate seems to be less consistent, so test over longer time period
			runtime = timer:new(10)
		end
		while runtime:running() and dpdk.running() do
			bufs:alloc(frame_size_without_crc)
                	for _, buf in ipairs(bufs) do
				local pkt = buf:getUdpPacket()
		        	pkt.ip4.src:set(baseIP + count % num_flows)
			end
                	bufs:offloadUdpChecksums()
			if ( method == "hardware" ) then
				txQueue:send(bufs)
			else
				for _, buf in ipairs(bufs) do
					buf:setRate(calibratedRate)
				end
				txQueue:sendWithDelay(bufs)
			end
			txStats:update()
			count = count +1
		end
		txStats:finalize()
		measuredRate = txStats.mpps.avg
		-- the measured rate must be within the tolerance window but also not exceed the desired rate
		if ( measuredRate > desiredRate or (desiredRate - measuredRate) > rate_accuracy ) then
			local correction = (1 - desiredRate/measuredRate)
			if ( calibrationCount > 0 ) then
				overcorrection =  (measuredRate - prevMeasuredRate) / (desiredRate - prevMeasuredRate)
				if ( overcorrection > 1 ) then
					printf("overcorrection ratio: %.4f\n", overcorrection)
					correction = correction/overcorrection
				end
			end
			local correction_ratio = 1 / (1 + correction)
			calibratedRate = calibratedRate * correction_ratio
			prevMeasuredRate = measuredRate
                        printf("measuredRate: %.4f  desiredRate:%.4f  new correction: %.4f  new correction_ratio: %.4f  new calibratedRate: %.4f ", measuredRate, desiredRate, correction, correction_ratio, calibratedRate)
		else
			isCalibrated = true
		end
		calibrationCount = calibrationCount +1
	until ( isCalibrated  == true )
	printf("Rate calibration complete\n") 

        local results = {calibratedRate}
        return results
end

function counterSlave(rxQueue, run_time)
	local rxStats = stats:newDevRxCounter(rxQueue, "plain")
	local runtime = timer:new(run_time)
	while runtime:running() and dpdk.running() do
		rxStats:update()
	end
        rxStats:finalize()
        local results = {rxStats.total}
        return results
end

function loadSlave(txQueue, rate, calibratedRate, frame_size, run_time, num_flows, method)
	printf("Testing %.2f Mfps", rate)
	local frame_size_without_crc = frame_size - 4
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	local mem = memory.createMemPool(function(buf)
		buf:getUdpPacket():fill{
			pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
			ethSrc = txQueue, -- get the src mac from the device
			ethDst = ETH_DST,
			ip4Dst = IP_DST,
			udpSrc = PORT_SRC,
			udpDst = PORT_DST,
		}
	end)
	local bufs = mem:bufArray()
	local baseIP = parseIPAddress(IP_SRC)
	local runtime = timer:new(run_time)
	local txStats = stats:newDevTxCounter(txQueue, "plain")
	local count = 0
	if ( method == "hardware" ) then
		txQueue:setRateMpps(calibratedRate)
	end
	while runtime:running() and dpdk.running() do
		bufs:alloc(frame_size_without_crc)
                for _, buf in ipairs(bufs) do
			local pkt = buf:getUdpPacket()
		        pkt.ip4.src:set(baseIP + count % num_flows)
		end
                bufs:offloadUdpChecksums()
		if ( method == "hardware" ) then
			txQueue:send(bufs)
		else
			for _, buf in ipairs(bufs) do
				buf:setRate(calibratedRate)
			end
			txQueue:sendWithDelay(bufs)
		end
		txStats:update()
		count = count + 1
	end
	txStats:finalize()
        local results = {txStats.total, txStats.mpps.avg}
        return results
end

function timerSlave(txQueue, rxQueue, frame_size, run_time, num_flows, bidirec)
	local frame_size_without_crc = frame_size - 4
	local rxDev = rxQueue.dev
	rxDev:filterTimestamps(rxQueue)
	local timestamper = ts:newUdpTimestamper(txQueue, rxQueue)
	local hist = hist()
	-- timestamping starts after and finishes before the main packet load starts/finishes
	dpdk.sleepMillis(LATENCY_TRIM)
	local runtime = timer:new(run_time - LATENCY_TRIM/1000*2)
	local baseIP = parseIPAddress(IP_SRC)
	local rateLimit = timer:new(0.01)
	while runtime:running() and dpdk.running() do
		rateLimit:wait()
		local lat = timestamper:measureLatency();
		if (lat) then
                	hist:update(lat)
		end
		rateLimit:reset()
	end
	dpdk.sleepMillis(LATENCY_TRIM + 1000) -- the extra 1000 ms ensures the stats are output after the throughput stats
	hist:save("hist.csv")
	hist:print("Histogram")
end
