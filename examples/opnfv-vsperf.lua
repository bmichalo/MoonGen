-- vim:ts=4:sw=4:noexpandtab
--- This script can be used to determine if a device is affected by the corrupted packets
--  that are generated by the software rate control method.
--  It generates CBR traffic via both methods and compares the resulting latency distributions.
--  TODO: this module should also test L3 traffic (but not just L3 due to size constraints (timestamping limitations))
local dpdk		= require "dpdk"
local memory	= require "memory"
local ts		= require "timestamping"
local device	= require "device"
local filter	= require "filter"
local timer		= require "timer"
local stats		= require "stats"
local hist		= require "histogram"

-- required here because this script creates *a lot* of mempools
memory.enableCache()

local REPS = 1
local run_time = 20
local LATENCY_TRIM = 3000 -- time in ms to delayied start and early end to latency mseasurement, so we are certain main packet load is present
local FRAME_SIZE = 64
local BIDIREC = 0 --do not do bidirectional test
local LATENCY = 1 --do not get letency measurements
local MAX_PCT_LOSS = 0
local LINE_RATE = 10000000000 -- 10Gbps
local RATE_RESOLUTION = 0.02
local ETH_DST   = "10:11:12:13:14:15" -- src mac is taken from the NIC
local IP_SRC    = "192.168.0.1"
local IP_DST    = "10.0.0.1"
local PORT_SRC  = 1234
local NUM_FLOWS = 256 -- src ip will be IP_SRC + (0..NUM_FLOWS-1)

function master(...)
	local port1, port2, frame_size, bidirec, max_pct_loss, num_flows, maxRate = tonumberall(...)
	if not port1 or not port2 then
		errorf("usage: port1 port2 [frame_size bidirec max_pct_loss num_flows max_rate]")
	end
	frame_size = frame_size or FRAME_SIZE
	bidirec = bidirec or BIDIREC
	max_pct_loss = max_pct_loss or MAX_PCT_LOSS
	maxRate = maxRate or (LINE_RATE /(frame_size*8 +64 +96) /1000000) --maxRate is in millions per second
	num_flows = num_flows or NUM_FLOWS
	rateResolution = RATE_RESOLUTION
	latency = LATENCY

	printf("bidirec: %d", bidirec);
	printf("max_rate: %.2f", maxRate);
	printf("num_flows: %d", num_flows);
	printf("rate_resolution: %.2f", rateResolution);
	printf("max_pct_loss: %.2f", max_pct_loss);

	-- assumes port1 and port2 are not the same
	local devs = {}
	local numQueues = 1 
	if (bidirec == 1) then
		numQueues = numQueues + 1 
	end
	if (latency == 1) then
		numQueues = numQueues + 1 
	end
	devs[1] = device.config(port1, numQueues, numQueues)
	devs[2] = device.config(port2, numQueues, numQueues)

	device.waitForLinks()
	local prevRate = 0
	local prevPassRate = 0
	local frame_loss = 0
	local prevFailRate = maxRate
	local rate = maxRate
	local method = "hardware"
	while ( math.abs(rate - prevRate) > rateResolution ) do
		r = {frame_loss, rxMpps}
		launchTest(devs[1], devs[2], rate, bidirec, 0, frame_size, run_time, num_flows, method, r)
		frame_loss = r[1]
		rxMpps = r[2]
		prevRate = rate
	        if frame_loss > max_pct_loss then --failed to have <= max_pct_loss, lower rate
			printf("this test failed because the frame loss percentage, %.8f, was higher than the maximum allowed (%.2f)\n", frame_loss, max_pct_loss);
			prevFailRate = rate
			rate = ( prevPassRate + rate ) / 2
		else --acceptable packet loss, increase rate
			printf("this test passed because the frame loss percentage, %.8f, was not higher than the maximum allowed (%.2f)\n", frame_loss, max_pct_loss);
			prevPassRate = rate
			rate = (prevFailRate + rate ) / 2
		end
		printf("\n")
		dpdk.sleepMillis(500)
		if not dpdk.running() then
			break
		end
	end

	local frame_loss = 0
	run_time = run_time * 2 --use a longer runtime for final validation
	r = {frame_loss, rxMpps}
	printf("Starting final validation\n");
	launchTest(devs[1], devs[2], rate, bidirec, latency, frame_size, run_time, num_flows, method, r)
	printf("Stopping final validation\n");
	frame_loss = r[1]
	rxMpps = r[2]
	prevRate = rate
        if frame_loss > max_pct_loss then
		printf("final validation of %.2f Mpps failed because the frame loss percentage, %.8f, was higher than the maximum allowed (%.2f)\n", rxMpps, frame_loss, max_pct_loss);
	else
		printf("final validation of %.2f Mpps passed because the frame loss percentage, %.8f, was not higher than the maximum allowed (%.2f)\n", rxMpps, frame_loss, max_pct_loss);
	end
	printf("\n")
	dpdk.sleepMillis(500)
end

function launchTest(dev1, dev2, rate, bidirec, latency, frame_size, run_time, num_flows, method, t)
		-- t = {frame_loss, rxMpps}

		local total_rate = rate
		local qid = 0

		if (bidirec == 1) then
			total_rate = rate * 2
		end

		printf("Testing frame rate (millions per second) with %s rate control: %.2f", method , total_rate)
		dev1:getTxQueue(qid):setRateMpps(method == "hardware" and rate or 0)
		loadTask1a = dpdk.launchLua("loadSlave", dev1:getTxQueue(qid), dev2:getRxQueue(qid), method == "software" and rate, frame_size, run_time, num_flows)
		qid = qid + 1

		if (bidirec == 1) then
			dev2:getTxQueue(qid):setRateMpps(method == "hardware" and rate or 0)
			loadTask1b = dpdk.launchLua("loadSlave", dev2:getTxQueue(qid), dev1:getRxQueue(qid), method == "software" and rate, frame_size, run_time, num_flows)
			qid = qid + 1
		end

		if (latency == 1) then
			loadTask2a = dpdk.launchLua("timerSlave", dev1:getTxQueue(qid), dev2:getRxQueue(qid), frame_size, run_time, num_flows)
			qid = qid + 1
		end

		local r1 = {}
		r1 = loadTask1a:wait()
		local total_frame_loss = r1[1]
		local total_rxMpps = r1[2]
		
		if (bidirec == 1) then
			local r2 = {}
			r2 = loadTask1b:wait()
			total_frame_loss = (r1[1] +r2[1]) /2
			total_rxMpps = r1[2] +r2[2]
		end

		if (latency == 1) then
			loadTask2a:wait()
		end

		t[1] = total_frame_loss
		t[2] = total_rxMpps
end

function loadSlave(txQueue, rxQueue, rate, frame_size, run_time, num_flows)
	local frame_size_without_crc = frame_size - 4
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	local mem = memory.createMemPool(function(buf)
		buf:getUdpPacket():fill{
			pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
			ethSrc = txQueue, -- get the src mac from the device
			ethDst = ETH_DST,
			-- ipSrc will be set later as it varies
			ip4Dst = IP_DST,
			udpSrc = PORT_SRC,
			udpDst = port,
			-- payload will be initialized to 0x00 as new memory pools are initially empty
		}
	end)
	local bufs = mem:bufArray()
	local runtime = timer:new(run_time)
	local rxStats = stats:newDevRxCounter(rxQueue, "plain")
	local txStats = stats:newDevTxCounter(txQueue, "plain")
	local count = 0
	local baseIP = parseIPAddress(IP_SRC)
	while runtime:running() and dpdk.running() do
		bufs:alloc(frame_size_without_crc)
                for _, buf in ipairs(bufs) do
			local pkt = buf:getUdpPacket()
			-- Using random here tends to slow down the Tx rate
			-- pkt.ip4.src:set(baseIP + math.random(num_flows) - 1)
			-- For now, just increment with count and limit with num_flows
			-- Later, maybe consider pre-allocating a list of random IPs
			pkt.ip4.src:set(baseIP + count % num_flows)
		end
		if rate then
			for _, buf in ipairs(bufs) do
				buf:setRate(rate)
			end
			txQueue:sendWithDelay(bufs)
		else
			txQueue:send(bufs)
		end
		rxStats:update()
		txStats:update()
		count = count + 1
	end
	dpdk.sleepMillis(500)
	rxStats:update()
	txStats:update()
	txStats:finalize()
	rxStats:finalize()
	--stats.name, direction,
	--stats.mpps.avg, stats.mpps.stdDev,
	--stats.mbit.avg, stats.mbit.stdDev,
	--stats.wireMbit.avg, stats.wireMbit.stdDev
	local loss = txStats.total - rxStats.total
	if (loss < 0 ) then
		loss = 0
	end
	local pct_loss = loss / txStats.total * 100
	--printf("loop count: %d  frames dropped: %d (%.8f%%)", count, loss, loss / txStats.total * 100)
	--printf("Mpps: %.2f", rxStats.mpps.avg)
	local results = {pct_loss, rxStats.mpps.avg}
	return results
end

function timerSlave(txQueue, rxQueue, frame_size, run_time, num_flows, bidirec)
	local frame_size_without_crc = frame_size - 4
	local rxDev = rxQueue.dev
	rxDev:filterTimestamps(rxQueue)
	local timestamper = ts:newUdpTimestamper(txQueue, rxQueue)
	local hist = hist()
	-- timestamping starts after and finishes before the main packet load starts/finishes
	dpdk.sleepMillis(LATENCY_TRIM)
	local runtime = timer:new(run_time - LATENCY_TRIM/1000*2)
	local baseIP = parseIPAddress(IP_SRC)
	local rateLimit = timer:new(0.01)
	while runtime:running() and dpdk.running() do
		--local port = math.random(2048)
		--local lat = timestamper:measureLatency(frame_size_without_crc, function(buf)
		--	local pkt = buf:getUdpPacket()
		--	pkt:fill{
		--		pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
		--		ethSrc = txQueue, -- get the src mac from the device
		--		ethDst = ETH_DST,
		--		-- ipSrc will be set later as it varies
		--		ip4Dst = IP_DST,
		--		udpSrc = PORT_SRC,
		--		udpDst = port,
		--	}
		--	pkt.ip4.src:set(baseIP + math.random(NUM_FLOWS) - 1)
		--end)
		--if lat then
		--	hist:update(lat)
		--end
		rateLimit:wait()
		local lat = timestamper:measureLatency();
		if (lat) then
                	hist:update(lat)
		end
		rateLimit:reset()
	end
	dpdk.sleepMillis(LATENCY_TRIM + 1000) -- the extra 1000 ms ensures the stats are output after the throughput stats
	hist:save("hist.csv")
	hist:print("Histogram")
end
