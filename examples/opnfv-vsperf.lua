-- vim:ts=4:sw=4:noexpandtab
--- This script can be used to determine if a device is affected by the corrupted packets
--  that are generated by the software rate control method.
--  It generates CBR traffic via both methods and compares the resulting latency distributions.
--  TODO: this module should also test L3 traffic (but not just L3 due to size constraints (timestamping limitations))
local dpdk      = require "dpdk"
local memory    = require "memory"
local ts        = require "timestamping"
local device    = require "device"
local filter    = require "filter"
local timer     = require "timer"
local stats     = require "stats"
local hist      = require "histogram"
-- required here because this script creates *a lot* of mempools
-- memory.enableCache()

-------------------------------------------------------------------------------
-- "Constants"
-------------------------------------------------------------------------------
local REPS = 1
local run_time = 60
local LATENCY_TRIM = 3000 -- time in ms to delayied start and early end to latency mseasurement, so we are certain main packet load is present
local FRAME_SIZE = 64
local BIDIREC = 0 --do not do bidirectional test
local LATENCY = 0 --do not get letency measurements
local MAX_FRAME_LOSS_PCT = 0
local LINE_RATE = 10000000000 -- 10Gbps
local RATE_GRANULARITY = 0.1
local TX_HW_RATE_TOLERANCE_MPPS = 0.250  -- The acceptable difference between actual and measured TX rates (in Mpps)
local TX_SW_RATE_TOLERANCE_MPPS = 0.250  -- The acceptable difference between actual and measured TX rates (in Mpps)
local ETH_DST   = "10:11:12:13:14:15" -- src mac is taken from the NIC
local IP_SRC    = "192.168.0.10"
local IP_DST    = "10.0.0.1"
local PORT_SRC  = 1234
local PORT_DST  = 1234
local NUM_FLOWS = 256 -- src ip will be IP_SRC + (0..NUM_FLOWS-1)


function master(...)
	local port1, port2, frame_size, bidirec, max_acceptable_frame_loss_pct, num_flows, max_line_rate_Mfps = tonumberall(...)

        if not port1 or not port2 then
            printf("\n\n");
	    printf("Usage: \n");
	    printf("         opnfv-vsperf.lua Port1 Port2 [Frame Size] [Traffic Direction] [Maximum Acceptable Frame Loss] [Number of Flows] [Maximum Frames Per Second]\n\n");
            printf("             where:\n");
            printf("                Port1 ............................ The first DPDK enabled port of interest, e.g. 0\n");
            printf("                Port2 ............................ The second DPDK enabled port of interest, e.g. 1\n");
            printf("                Frame Size ....................... Frame size in bytes.  This is the 'goodput' payload size in bytes.  It does not include");
            printf("                                                   the preamble (7 octets), start of frame delimited (1 octet), and interframe gap (12 octets). ");
            printf("                                                   The default size is 64. \n");
            printf("                Traffic Direction ................ Unidirectional (0) or bidirectional (1) traffic flow between Port1 and Port2.  Default is unidirectional\n");
            printf("                Maximum Acceptable Frame Loss .... Percentage of acceptable packet loss.  Default is 0\n");
            printf("                Number of Flows .................. Number of packet flows.  Default is 256\n");
            printf("                Maximum Frames Per Second ........ The maximum number of frames per second (in Mfps).  For a 10 Gbps connection, this would be 14.88 (also the default)");
            printf("\n\n");
            return
	end

	frame_size = frame_size or FRAME_SIZE
	bidirec = bidirec or BIDIREC
	max_acceptable_frame_loss_pct = max_acceptable_frame_loss_pct or MAX_FRAME_LOSS_PCT
	max_line_rate_Mfps = max_line_rate_Mfps or (LINE_RATE /(frame_size*8 +64 +96) /1000000) --max_line_rate_Mfps is in millions per second
	num_flows = num_flows or NUM_FLOWS
	rate_granularity = RATE_GRANULARITY
	latency = LATENCY

	-- assumes port1 and port2 are not the same
	local numQueues = 1 
	if (latency == 1) then
		numQueues = numQueues + 1 
	end

	local prevRate = 0
	local prevPassRate = 0
	local frame_loss = 0
	local prevFailRate = max_line_rate_Mfps
	local rate = max_line_rate_Mfps
        local method = "hardware"
        local final_validation_ctr = 0
	if ( method == "hwardware" ) then
		tx_rate_tolerance = TX_HW_RATE_TOLERANCE_MPPS
	else
		tx_rate_tolerance = TX_SW_RATE_TOLERANCE_MPPS
	end

	printf("\n\nStarting binary search for maximum throughput with no more than %.8f%% packet loss", max_acceptable_frame_loss_pct);
	while ( math.abs(rate - prevRate) > rate_granularity or final_validation_ctr < 1 ) do
                local devs = {}
		devs[1] = device.config{ port = port1, rxQueues = numQueues, txQueues = numQueues}
		devs[2] = device.config{ port = port2, rxQueues = numQueues, txQueues = numQueues}
                device.waitForLinks()

                --printf("TOP OF WHILE LOOP:  Testing with prevPassRate = %.2f, prevFailRate = %.2f, prevRate = %.2f, rate = %.2f", prevPassRate, prevFailRate, prevRate, rate); 
	        --r = {dev1_total_tx_frames, dev2_total_tx_frames, dev1_total_rx_frames, dev2_total_rx_frames, dev1_txMpps, dev2_txMpps}
	        local r = {}
		launchTest(devs[1], devs[2], rate, bidirec, 0, frame_size, run_time, num_flows, method, r)
                local dev1_total_tx_frames = r[1]
                local dev2_total_tx_frames = r[2]
                local dev1_total_rx_frames = r[3]
                local dev2_total_rx_frames = r[4]
		local dev1_avg_txMpps = r[5]
		local dev2_avg_rxMpps = r[6]

		--TODO: fix for bidirectional
		--local rateDiff = math.abs(rate - dev1_avg_txMpps)
                --if (rateDiff > tx_rate_tolerance) then
                    --printf("ABORT TEST:  difference between actual and requested Tx rate %.2f is greater than allowed %.2f Mfs", rateDiff dev1_txMpps)
                    --return
                --end

		prevRate = rate
		local dev1_lost_frames = dev1_total_tx_frames - dev2_total_rx_frames
		local dev2_lost_frames = dev2_total_tx_frames - dev1_total_rx_frames
		local frame_loss_pct = 100 * (dev1_lost_frames + dev2_lost_frames) / (dev1_total_tx_frames + dev2_total_tx_frames)
	        if frame_loss_pct > max_acceptable_frame_loss_pct then --failed to have <= max_acceptable_frame_loss_pct, lower rate
			printf("Test Result:  FAILED - frame loss (%d, %.8f%%), which is greater than the maximum allowed (%.8f%%)", dev1_lost_frames + dev2_lost_frames, frame_loss_pct, max_acceptable_frame_loss_pct);
			prevFailRate = rate
			rate = ( prevPassRate + rate ) / 2
                        --printf("FAIL WHILE LOOP:  Testing with prevPassRate = %.2f, prevFailRate = %.2f, prevRate = %.2f, 'new'rate = %.2f", prevPassRate, prevFailRate, prevRate, rate); 
		else --acceptable packet loss, increase rate
			printf("Test Result:  PASSED - frame loss (%d, %.8f%%), which is not greater than the maximum allowed (%.8f%%)", dev1_lost_frames + dev2_lost_frames, frame_loss_pct, max_acceptable_frame_loss_pct);
			prevPassRate = rate
			rate = (prevFailRate + rate ) / 2
                        --printf("PASS WHILE LOOP:  Testing with prevPassRate = %.2f, prevFailRate = %.2f, prevRate = %.2f, 'new'rate = %.2f", prevPassRate, prevFailRate, prevRate, rate); 
		end
		printf("\n")
		dpdk.sleepMillis(500)
		if not dpdk.running() then
			break
		end
		printf("\n")

	        if math.abs(rate - prevRate) < rate_granularity then
                    printf("\n");
	            printf("Starting final validation");
                    printf("\n\n");
                    --printf("VALIDATION WHILE LOOP:  Testing with prevPassRate = %.2f, prevFailRate = %.2f, prevRate = %.2f, rate = %.2f", 
                            --prevPassRate, prevFailRate, prevRate, rate); 
	            launchTest(devs[1], devs[2], prevPassRate, bidirec, latency, frame_size, run_time, num_flows, method, r)
                    printf("\n\n");
	            printf("Stopping final validation");
                    printf("\n\n");
                    local dev1_total_tx_frames = r[1]
                    local dev2_total_tx_frames = r[2]
                    local dev1_total_rx_frames = r[3]
                    local dev2_total_rx_frames = r[4]
		    local dev1_avg_txMpps = r[5]
		    local dev2_avg_rxMpps = r[6]

                    if math.abs(rate - dev1_avg_txMpps) > tx_rate_tolerance then
                        printf("\n\nABORT TEST:  Device 1 transmit rate not correct. \n");
                        printf("             The desired TX Rate = %.2f Mpps, the measured TX Rate = %.2f Mpps\n", rate, dev1_txMpps);
                        printf("             The difference between rates can not exceed %.2f Mpps\n\n", tx_rate_tolerance);
                        return
                    end
                    
		    local dev1_lost_frames = dev1_total_tx_frames - dev2_total_rx_frames
		    local dev2_lost_frames = dev2_total_tx_frames - dev1_total_rx_frames
		    local frame_loss_pct = 100 * (dev1_lost_frames + dev2_lost_frames) / (dev1_total_tx_frames + dev2_total_tx_frames)
	            if frame_loss_pct > max_acceptable_frame_loss_pct then --failed to have <= max_acceptable_frame_loss_pct, lower rate
                        printf("\n*********************************************************************************************");
                        printf("* Final Validation Test Result:  FAILED\n" ..
                               "*     The validation of %.2f Mfps failed because the traffic throughput loss was %.8f %%, \n" ..
                               "*     which is higher than the maximum allowed (%.8f %%) loss", 
                               aggregate_avg_rxMpps, avg_device_frame_loss, max_acceptable_frame_loss_pct);
                        printf("*********************************************************************************************\n");
                        prevFailRate = prevPassRate
                        prevPassRate = 0
			rate = ( prevPassRate + rate ) / 2
	            else
                        printf("\n*********************************************************************************************");
                        printf("* Final Validation Test Result:  PASSED\n" ..
                               "*     The validation of %.2f Mfps passed because the traffic throughput loss was %.8f %%, \n" ..
                               "*     which did not exceed the maximum allowed (%.8f %%) loss", 
                               aggregate_avg_rxMpps, avg_device_frame_loss, max_acceptable_frame_loss_pct);
                        printf("*********************************************************************************************\n");

                        printf("#############################################################################################\n");
                        printf("RFC 2544 Test Results Summary From Final Validation\n\n");

	                printf("Measured Aggregate Average Throughput (Mfps) ................ %.2f", aggregate_avg_rxMpps);
	                printf("Frame Size .................................................. %d", frame_size);
                        
                        if (bidirec == 1) then
	                    printf("Traffic Flow Direction ...................................... Bidirectional");
	                    printf("Maximum Theoretical Line Rate Throughput (Mfps) ............. %.2f", 2 * max_line_rate_Mfps);
                        else
	                    printf("Traffic Flow Direction ...................................... Unidirectional");
	                    printf("Maximum Theoretical Line Rate Throughput (Mfps) ............. %.2f", max_line_rate_Mfps);
                        end

	                printf("Number of Data Flows ........................................ %d", num_flows);
	                printf("Rate Granularity (Mfps) ......................................... %.2f", rate_granularity);
	                printf("Maximum Acceptable Frame Loss (%%) ........................... %.8f", max_acceptable_frame_loss_pct);
                        printf("\n");
	                printf("Network Device ID ........................................... %d", port1);
                        --printf("    Average Rx Frame Count (Mfps) ........................... %.2f", dev1_rxMpps);
                        printf("    Rx Frame Count .......................................... %d", dev1_total_rx_frames);
                        printf("    Tx Frame Count .......................................... %d", dev1_total_tx_frames);
                        printf("    Frame Loss Count......................................... %d", dev1_frame_loss);
                        printf("\n");
	                printf("Network Device ID ........................................... %d", port2);
                        --printf("    Average Rx Frame Count (Mfps) ........................... %.2f", dev2_rxMpps);
                        printf("    Rx Frame Count .......................................... %d", dev2_total_rx_frames);
                        printf("    Tx Frame Count .......................................... %d", dev2_total_tx_frames);
                        printf("    Frame Loss Count......................................... %d\n", dev2_frame_loss);
                        printf("#############################################################################################\n");
                        printf("\n\n");
                        final_validation_ctr = 1
	            end
		    dpdk.sleepMillis(500)
		    if not dpdk.running() then
		    	break
		    end
		end
	end
	dpdk.sleepMillis(500)
end

function launchTest(dev1, dev2, rate, bidirec, latency, frame_size, run_time, num_flows, method, t)
		local total_rate = rate
		local qid = 0
		if (bidirec == 1) then
			total_rate = rate * 2
		end

		calibrateTask1a = dpdk.launchLua("calibrateSlave", dev1:getTxQueue(qid), rate, frame_size, num_flows, method)
		local c1 = {}
		c1 = calibrateTask1a:wait()
		dev1CalibratedRate = c1[1]
		if (bidirec == 1) then
			calibrateTask2a = dpdk.launchLua("calibrateSlave", dev2:getTxQueue(qid), rate, frame_size, num_flows, method)
			c1 = calibrateTask2a:wait()
			dev2CalibratedRate = c1[1]
		end

		-- first start the tasks that count reveiced packets
		rxTask1a = dpdk.launchLua("counterSlave", dev2:getRxQueue(qid), run_time + 6)
		if (bidirec == 1) then
			rxTask2a = dpdk.launchLua("counterSlave", dev1:getRxQueue(qid), run_time + 6)
		end
		dpdk.sleepMillis(3000)

		-- now start the tasks that generate the load
		loadTask1a = dpdk.launchLua("loadSlave", dev1:getTxQueue(qid), rate, dev1CalibratedRate, frame_size, run_time, num_flows, method)
		if (bidirec == 1) then
			loadTask1b = dpdk.launchLua("loadSlave", dev2:getTxQueue(qid), rate, dev2CalibratedRate, frame_size, run_time, num_flows, method)
		end

		-- and optinally take latency measurements
		if (latency == 1) then
			qid = qid + 1
			loadTask2a = dpdk.launchLua("timerSlave", dev1:getTxQueue(qid), dev2:getRxQueue(qid), frame_size, run_time, num_flows)
		end

               	local dev1_total_tx_frames = 0
               	local dev2_total_tx_frames = 0
               	local dev1_total_rx_frames = 0
               	local dev2_total_rx_frames = 0
		local dev1_avg_txMpps = 0
		local dev2_avg_rxMpps = 0
                
		-- wait for the tasks that generate load to finish
		local r1 = {}
		r1 = loadTask1a:wait()
                dev1_total_tx_frames = r1[1]
		dev1_avg_txMpps = r1[2]
		if (bidirec == 1) then
		    local r2 = {}
		    r2 = loadTask1b:wait()
                    dev2_total_tx_frames = r2[1];
		    dev2_avg_txMpps = r2[2]
		end

		-- wait for the tasks that count received packets to finish
		rx1 = rxTask1a:wait()
                dev2_total_rx_frames = rx1[1]
		if (bidirec == 1) then
			rx2 = rxTask2a:wait()
                	dev1_total_rx_frames = rx2[1]
                end
                
		-- finally, wait for latency task if one was used
		if (latency == 1) then
			loadTask2a:wait()
		end

                t[1] = dev1_total_tx_frames
                t[2] = dev2_total_tx_frames
                t[3] = dev1_total_rx_frames
                t[4] = dev2_total_rx_frames
		t[5] = dev1_avg_txMpps
		t[6] = dev2_avg_txMpps
end

function calibrateSlave(txQueue, desiredRate, frame_size, num_flows, method)
	printf("Calibrating %s tx rate for %.2f Mfs",  method , desiredRate)
	local frame_size_without_crc = frame_size - 4
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	local mem = memory.createMemPool(function(buf)
		buf:getUdpPacket():fill{
			pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
			ethSrc = txQueue, -- get the src mac from the device
			ethDst = ETH_DST,
			ip4Dst = IP_DST,
			udpSrc = PORT_SRC,
			udpDst = PORT_DST,
		}
	end)
	local bufs = mem:bufArray()
	local baseIP = parseIPAddress(IP_SRC)
	local measuredRate = 0
	local prevMeasuredRate = 0
	local calibratedRate = desiredRate
	local isCalibrated = false
	local calibrationCount = 0
	local overcorrection = 1
	repeat
		local count = 0
		local txStats = stats:newDevTxCounter(txQueue, "plain")
		if ( method == "hardware" ) then
			txQueue:setRateMpps(calibratedRate)
			rate_accuracy = TX_HW_RATE_TOLERANCE_MPPS / 2
			runtime = timer:new(5)
		else
			rate_accuracy = TX_SW_RATE_TOLERANCE_MPPS / 2
			-- s/w rate seems to be less consistent, so test over longer time period
			runtime = timer:new(10)
		end
		while runtime:running() and dpdk.running() do
			bufs:alloc(frame_size_without_crc)
                	for _, buf in ipairs(bufs) do
				local pkt = buf:getUdpPacket()
		        	pkt.ip4.src:set(baseIP + count % num_flows)
			end
                	bufs:offloadUdpChecksums()
			if ( method == "hardware" ) then
				txQueue:send(bufs)
			else
				for _, buf in ipairs(bufs) do
					buf:setRate(calibratedRate)
				end
				txQueue:sendWithDelay(bufs)
			end
			txStats:update()
			count = count +1
		end
		txStats:finalize()
		measuredRate = txStats.mpps.avg
		-- the measured rate must be within the tolerance window but also not exceed the desired rate
		if ( measuredRate > desiredRate or (desiredRate - measuredRate) > rate_accuracy ) then
			local correction = (1 - desiredRate/measuredRate)
			if ( calibrationCount > 0 ) then
				overcorrection =  (measuredRate - prevMeasuredRate) / (desiredRate - prevMeasuredRate)
				if ( overcorrection > 1 ) then
					printf("overcorrection ratio: %.4f\n", overcorrection)
					correction = correction/overcorrection
				end
			end
			local correction_ratio = 1 / (1 + correction)
			calibratedRate = calibratedRate * correction_ratio
			prevMeasuredRate = measuredRate
			printf("measuredRate: %.4f  desiredRate:%.4f\n", measuredRate, desiredRate)
			printf("new correction: %.4f\n", correction)
			printf("new correction_ratio: %.4f\n", correction_ratio)
			printf("new calibratedRate: %.4f\n", calibratedRate)
		else
			isCalibrated = true
		end
		calibrationCount = calibrationCount +1
	until ( isCalibrated  == true )
	printf("Rate calibration complete\n") 

        local results = {calibratedRate}
        return results
end

function counterSlave(rxQueue, run_time)
	local rxStats = stats:newDevRxCounter(rxQueue, "plain")
	local runtime = timer:new(run_time)
	while runtime:running() and dpdk.running() do
		rxStats:update()
	end
        rxStats:finalize()
        local results = {rxStats.total}
        return results
end

function loadSlave(txQueue, rate, calibratedRate, frame_size, run_time, num_flows, method)
	printf("Testing %.2f Mfps", rate)
	local frame_size_without_crc = frame_size - 4
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	local mem = memory.createMemPool(function(buf)
		buf:getUdpPacket():fill{
			pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
			ethSrc = txQueue, -- get the src mac from the device
			ethDst = ETH_DST,
			ip4Dst = IP_DST,
			udpSrc = PORT_SRC,
			udpDst = PORT_DST,
		}
	end)
	local bufs = mem:bufArray()
	local baseIP = parseIPAddress(IP_SRC)
	local runtime = timer:new(run_time)
	local txStats = stats:newDevTxCounter(txQueue, "plain")
	local count = 0
	if ( method == "hardware" ) then
		txQueue:setRateMpps(calibratedRate)
	end
	while runtime:running() and dpdk.running() do
		bufs:alloc(frame_size_without_crc)
                for _, buf in ipairs(bufs) do
			local pkt = buf:getUdpPacket()
		        pkt.ip4.src:set(baseIP + count % num_flows)
		end
                bufs:offloadUdpChecksums()
		if ( method == "hardware" ) then
			txQueue:send(bufs)
		else
			for _, buf in ipairs(bufs) do
				buf:setRate(calibratedRate)
			end
			txQueue:sendWithDelay(bufs)
		end
		txStats:update()
		count = count + 1
	end
	txStats:finalize()
        local results = {txStats.total, txStats.mpps.avg}
        return results
end

function timerSlave(txQueue, rxQueue, frame_size, run_time, num_flows, bidirec)
	local frame_size_without_crc = frame_size - 4
	local rxDev = rxQueue.dev
	rxDev:filterTimestamps(rxQueue)
	local timestamper = ts:newUdpTimestamper(txQueue, rxQueue)
	local hist = hist()
	-- timestamping starts after and finishes before the main packet load starts/finishes
	dpdk.sleepMillis(LATENCY_TRIM)
	local runtime = timer:new(run_time - LATENCY_TRIM/1000*2)
	local baseIP = parseIPAddress(IP_SRC)
	local rateLimit = timer:new(0.01)
	while runtime:running() and dpdk.running() do
		rateLimit:wait()
		local lat = timestamper:measureLatency();
		if (lat) then
                	hist:update(lat)
		end
		rateLimit:reset()
	end
	dpdk.sleepMillis(LATENCY_TRIM + 1000) -- the extra 1000 ms ensures the stats are output after the throughput stats
	hist:save("hist.csv")
	hist:print("Histogram")
end
